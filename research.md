Right now a personal - research project - but will have some useful sub-projects in the short term:

mujer implements several tools regarding image processing (bitmap and vector) that I need to implement and some research on libraries and technologies for non-trivial problems. Can be classified in two categories: 

 * **simple problems** mostly regarding formats, and bitmap / vector processing and

 * **complex problems** that involves feature detection, shape simplification and related problems (real world problems that graphic designers try to solve every day, by hand selecting or painting pixel by pixel, removing shape y shape, and I think it cna be solved more generically / optimally

 In general this project implements concrete processing tools that I need and the complex problems are kind of a personal  research on non trivial problems that often require common human sense.

Also a motivation is to familiarize with libraries like paper.js, ttracking.js and similar.

## Small / Simple / Concrete / optimal-soluble problems:

small problems related with vector graphics optimization, svg-pdf transformation bitmap / vector modifications / queries, etc:

 * import svg and pass convertALl so all shapes are converted to paths and `simplify` can be used
 http://paperjs.org/reference/textitem/
 * import a svg document, apply optimizarions and export it as SVG / PDF / JSON formats
 * `simplify` optimization which reduces a svg file generated by geometrize (very image tracers more than three sizes. 
 * This optimization is not done by svgo
 * import svg / JSON and output PDF (PDF is write only - cannot be imported)
   * test if pdfs are available im the browser (down stink so)
 * apper-js   
 * http://paperjs.org/reference/textitem/ - simple API to print text on SVGs and others
 js api and cli for all od this


## Complex problem 1 : extract shapes from photo by color matching

A designer does not have to create a logo/banner/etc but he/she is given an existing photo of it and its first task is to extract it, clearly, removing the "background" ann (probably) finally convert it to a vector graphic to be plotted.

Imagine they give a tshert with a graphic or a nuylon bag or a photo or a luckly png. So the background has noise and even could be not 100% flat.

Also the graphic to extract might consists on several shapes each identifying with a color. 

We can assume these colors don't conflict and neither the rest of the object that doest't match anything.


 technology  try to solve the problem of extracting a diffuse shape from a photo removing the rest of it
User gives 1 or more colors C1, c2 and for each an optional threshold to match pixels with similar colors. 

Should support both bitmaps and vectors. 

```
interface  ShapeMatch {
  sourceColor: Color
  threshold: number
  resultColor: Color
}
interface extractShapesByColorOptions {
  shapes: ShapeMatch[]
  /** what to do with the rest (non matching regions */)
  rest?: 'dnothing'|'transparent'|'color'
}
interface extractShapesByColorOptions {
  resultImage: Buffer|string
  shapes: Area[]
  rest: Area
}
extractShapesByColor(options:Options): extractShapesByColorOptionsResult
```


The progrma should: 
identify pixels matching each given color (in the threshold) and pixels that doesn't match. the program is not responsible fo modifying the image could be other...



# Complex Problem 2: Simplify vector graphics paths

 * image tracing technologies such as geometrice, imagetracerjs, potrace, and others are good to generate a SVG from a bitmap. Unfortunately the result doucmnte has A LOT of shapres , 99% of them redundant or even not representing well (errors) the visual shapes.  This don't allow people that need to use devides like plotters to use these (cuttting material devices need simple input vector shapes.)

 Can we UNION shapes that are closer than a given threshold into one single shape ?  answer us no - we need 1 factor that "relates" -  shapes. That coul dbe color. it could be given a distance threshold and  a color thresold, divide the shapes in subsets such as 1) all shapes in set S are in the same color segment. 2) each shape is closer than distanceT from another shape of the subset. There could be a second threshold for quantity sich as also subsets must be bigger than it and a nn option for an action on shapes that didn't matched any set (we consider them errors).

```
interface Options {

  /** color  threshold:  Assume a shape has only one color. then it could be : if in set S there exist a shape B which color distance to shape A's color is lower than the threshold then A belong to B's Set. There ould be parameters to change this poolicy, such as A color distance my be lower than the threshold for all elements in the set, or for a percent of elements in the set. (similar to distance threshold. */
  shapeColorThreshold: number

  shapeColorPolucy?: 'anyOf'|'allOf'|number

  /**distance threshold. could be: (A.points.find(ap=>set.shapes.find(B=>B.points.find(bp=>dist(ap, bp)<distanceT))) ? true : false . This is if shape A has a point which is closer to any point of any shape in the set S then A belongs to S. There could be options to change this policy - for example A must have all its points closer, or a threshold of its points closer, etc*/ 
  shapeDistanceThreshold:T number

  shapeDistancePolicy: 'anyOf'|'allOf'|number

  /** for being a set, shapes matchin the set needs to be more than this number. THe algoright could still return all sets no matter the size and then another program decide what to do with them ?  */
  setLengthThreshold: number

  /** for being a set, its are must be bigger than this number */
  setAreaThreshold:number

  /** optional - for being a set,it cannot be other set closer than this number to it?  (must be sufficiently separated from other sets */ 
  setDistancetThreshold?

  setDistanceTPolicy?: oneOf|anyOf|lowerThen|greaterThan

  unmatchedShapesAction:? 'ignore'|'remove'|((s:Shape)=>Shape)

  /** if a set average color is to similar to another set then we could UNION them ? */
  setColorPolicy ? 
}
```
 * how we define starting sets ? 
  * group by color: using node-vibrant to build color segments : 
   * could be using edge detection and identifying areas separated by them ? Assume there are no human hints on areas - algorthm must be able to fragment the graphic on areas by it self.  similar to edge detection it could be areas with bit color changes (freq)

 * what happes with shapes that match more than one set ? we could consider them redundant and also coul dbe a option for an action on those.




related techs : 

 * http://paperjs.org/tutorials/images/using-pixel-colors/
 * http://paperjs.org/tutorials/images/color-averaging-image-areas/
 * http://paperjs.org/reference/compoundpath/ (path goruping)
 * color detection https://trackingjs.com/examples/color_hello_world.html
feature similarities https://trackingjs.com/examples/brief.html
shape segment https://www.marvinj.org/en/examples/robotSegmentation.html
https://www.marvinj.org/en/examples/findTextRegions.html
text recog: https://github.com/tesseract-ocr/tesseract/wiki

segmentize svg https://robbykraft.github.io/svg-segmentize/test/


ttf to svg https://helpfulsheep.com/2015-03-25-converting-svg-fonts-to-svg/



shape colisions
https://www.npmjs.com/package/detect-collisions#anchor-demos


OT: layouts: https://www.npmjs.com/package/word-wrapper - https://github.com/Jam3/layout-bmfont-text

# UI libs vectors & editors
https://github.com/fritz-c/react-shape-editor#readme


spatial index https://github.com/mourner/rbush https://github.com/mourner/rbush-knn 


# transform shape
  https://www.npmjs.com/package/shape-expand-reduce


# hull / contour

https://www.npmjs.com/package/hull.js
https://www.npmjs.com/package/concaveman
2D isoline / contour extraction https://github.com/thi-ng/umbrella/tree/master/packages/geom-isoline
https://github.com/mattdesl/triangulate-contours

https://github.com/thi-ng/umbrella mega mono repo


# shape / pattern recogn / detection
   https://www.npmjs.com/package/alpha-shape

shape detectr and language https://github.com/MathieuLoutre/shape-detector/ - http://depts.washington.edu/madlab/proj/dollar/index.html
contornos: https://www.npmjs.com/package/hull.js
https://libraries.io/npm/outlines



# triangulation
  https://www.npmjs.com/package/cdt2d 
  https://mikolalysenko.github.io/clean-pslg/
https://github.com/memononen/tess2.js
https://www.npmjs.com/package/triangulate-polyline

https://www.npmjs.com/package/cdt2d

#  clipping
  https://github.com/thi-ng/umbrella/tree/master/packages/geom-clip 

 # intersection
  https://github.com/thi-ng/umbrella/tree/master/packages/geom-isec


#  geom poly 
  https://github.com/thi-ng/umbrella/tree/master/packages/geom-api
lib https://alexbol99.github.io/flatten-js/index.html
the contrary to simplify https://www.npmjs.com/package/chaikin-smooth
  https://github.com/thi-ng/umbrella/tree/master/packages/geom-poly-utils

resample, splkit interpolation, nearest pointhttps://github.com/thi-ng/umbrella/tree/master/packages/geom-resample : ampleUniform(opts.dist, opts.last) ; simplify (

#   closest
   https://github.com/thi-ng/umbrella/blob/master/packages/geom-closest-point/src/index.ts


  https://github.com/thi-ng/umbrella/tree/master/packages/geom-arc
  https://github.com/thi-ng/umbrella/tree/master/packages/geom-splines/src

# points, areas, perimeters, os polys   
https://github.com/thi-ng/umbrella/tree/master/packages/geom-poly-utils

# curve subdivisions: 
https://github.com/thi-ng/umbrella/tree/master/packages/geom-subdiv-curve


 * simplify all its pathd to optimize sie using http://paperjs.org/reference/path/#simplify
 * flatten paths (sharpen - round to square path edges)
 * smoth paths (blur analog for vector paths - round apath angles)
 * smooth the contrary to simplify https://www.npmjs.com/package/chaikin-smooth
 * https://www.npmjs.com/package/@thi.ng/geom
